import fire
from jira_agent.graph.graph import JiraGraph
import yaml
from collections import defaultdict
from dotenv import load_dotenv
import json

def main(config_file, **kwargs):
        load_dotenv()
        graph = JiraGraph()
        config = yaml.safe_load(open(config_file))
        filename = config['FILEPATH']
        count = config.get("COUNT",1)
        destination_path = config.get('DESTINATION_PATH')
        project_tool_calls = ["update_jira_project_lead",
                              "update_jira_project_description"]
        issue_tool_calls = ['create_jira_issue',
                            'perform_jira_transition']

        final_output = []
        new_data = defaultdict(list)
        with open(filename, 'r') as file:
            prompts = json.load(file)

        for values in prompts:
            counter = 0
            trajectories = []
            # based on the counter value call the graph to generate response
            while counter < count:
                prompt_type = values['action']
                user_prompt = values['query']
                result,trajectory_result = graph.serve(user_prompt)
                trajectory = [trajectory.model_dump() for trajectory in trajectory_result['messages']]
                trajectories.append(trajectory)
                counter += 1
            reference_trajectories = []
            for i,trajectory_info in enumerate(trajectories):
                response = []
                is_first = False
                response.append("__start__")
                for traject in trajectory_info:
                    # check whether the content is type AI
                    if traject['type'] == 'ai':
                        # if the content is generated by jira supervisor
                        if traject['name'] == 'jira_supervisor':
                            response.append(f"{traject['name']}")
                            response.append(f"{traject['name']}:__start__")
                            response.append(f"{traject['name']}:agent")
                            # if the message has tools called, check whether it called project agent or issue agent
                            if traject.get('tool_calls'):
                                response.append(f"{traject['name']}:tools")
                                for tools in traject.get('tool_calls'):
                                    if tools['name'] == 'transfer_to_jira_projects_agent':
                                        response.append(f"jira_projects_agent")
                                        response.append(f"jira_projects_agent:__start__")
                                        response.append(f"jira_projects_agent:agent")
                                    elif tools['name'] == 'transfer_to_jira_issues_agent':
                                        response.append(f"jira_issues_agent")
                                        response.append(f"jira_issues_agent:__start__")
                                        response.append(f"jira_issues_agent:agent")

                        # If the content is generated by issue agent or project agent
                        elif traject['name'] == 'jira_issues_agent' or traject['name'] == 'jira_projects_agent':
                            if traject.get('tool_calls') and traject.get('tool_calls')[0]['name'] == "transfer_back_to_jira_supervisor":
                                is_first = True
                                continue
                            if traject.get('tool_calls'):
                                if not is_first:
                                    response.append(f"{traject['name']}:tools")
                                    is_first = True
                                for tool in traject['tool_calls']:
                                    if tool['name'] in project_tool_calls or tool['name'] in issue_tool_calls:
                                        response.append(f"{traject['name']}:agent")
                                        response.append(f"{traject['name']}:tools")
                            else:
                                if not is_first:
                                    response.append(f"{traject['name']}:tools")
                                    is_first = True
                                response.append(f"{traject['name']}:agent")
                                response.append(f"{traject['name']}:generate_structured_response")
                reference_trajectories.append({f"Solution{i+1}": ";".join(response)})

            visited = set()
            trajectory_selected = []
            # Traverse over the list of trajectories and remove duplicates
            for trajectory in reference_trajectories:
                if list(trajectory.values())[0] not in visited:
                    visited.add(list(trajectory.values())[0])
                    trajectory_selected.append(trajectory)
            new_data[values['action']].append({
                "input": values["query"],
                "reference_trajectory": trajectory_selected,
            })
        with open(destination_path, 'w') as outfile:
            yaml.dump({"tests": dict(new_data)}, outfile, default_flow_style=False)

if __name__ == '__main__':
    # python3 generateReferenceTrajectory.py --config_file configs/generate_trajectory_config.yaml
    fire.Fire(main)
